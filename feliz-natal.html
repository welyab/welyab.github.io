<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Feliz Natal ‚Äî Dev Particles</title>
  <style>
    html, body { margin: 0; height: 100%; background: #05070f; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }

    .hud {
      position: fixed;
      left: 12px; top: 12px;
      display: flex; gap: 10px; align-items: center;
      color: rgba(255,255,255,.78);
      font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      user-select: none;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,.08);
      max-width: min(720px, calc(100vw - 24px));
    }
    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      white-space: nowrap;
    }
    .hint {
      position: fixed;
      left: 12px; bottom: 12px;
      color: rgba(255,255,255,.70);
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      user-select: none;
      background: rgba(0,0,0,.28);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);
      max-width: min(760px, calc(100vw - 24px));
    }
    .hint b { color: rgba(255,255,255,.92); }
    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <span class="pill">console.log("Feliz Natal!")</span>
  <span class="pill">üéÑ build: green</span>
  <span class="pill">CI ‚úÖ</span>
  <span class="pill">deploy: üéÅ</span>
</div>

<div class="hint">
  Passe o mouse (ou toque) perto das bolinhas: elas fogem at√© formar um <b>anel de equil√≠brio</b> ao redor do ponteiro.
  Afaste para elas voltarem ao texto. Dica: toque como se fosse um <span class="kbd">cursor</span> üëÜ
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // Mensagem com tema dev
  const MSG  = "Feliz Natal, Dev!";
  const SUB  = "git commit -m \"Merry Christmas\"";
  const SUB2 = "CI: ‚úÖ  |  tests: ‚úÖ  |  build: ‚úÖ  |  deploy: üéÅ";

  // Config
  const cfg = {
    dotRadius: 2.05,
    dotGap: 5,
    density: 1.0,

    // repuls√£o com equil√≠brio em anel:
    eqDist: 92,
    deadBand: 3,
    repelRadius: 200,
    repelStrength: 980,
    eps: 10,

    // retorno ao texto (mola)
    returnStrength: 0.080,

    // din√¢mica
    damping: 0.865,
    maxSpeed: 14,

    // est√©tica
    jitter: 0.0,
    dprLimit: 2
  };

  // Paleta (sem fixar em CSS, s√≥ no canvas)
  const BG_TOP = "#061027";
  const BG_BOT = "#03040a";

  // Ponteiro
  const pointer = { x: 0, y: 0, active: false };

  // Part√≠culas
  let particles = [];
  let W = 0, H = 0, dpr = 1;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function resize() {
    dpr = Math.min(window.devicePixelRatio || 1, cfg.dprLimit);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    buildParticlesFromText();
  }

  function drawBackground() {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, BG_TOP);
    g.addColorStop(1, BG_BOT);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // glow suave estilo "monitor"
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#43ff99"; // brilho verdinho sutil (apenas no background)
    ctx.beginPath();
    ctx.arc(W * 0.18, H * 0.22, Math.min(W, H) * 0.20, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // grade discreta
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    const step = 34;
    for (let x = 0; x <= W; x += step) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, H);
      ctx.stroke();
    }
    for (let y = 0; y <= H; y += step) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(W, y + 0.5);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function buildParticlesFromText() {
    const off = document.createElement("canvas");
    const octx = off.getContext("2d");
    off.width = W;
    off.height = H;

    octx.clearRect(0, 0, W, H);

    // tamanhos responsivos
    const mainSize = Math.max(44, Math.min(150, W * 0.095));
    const subSize  = Math.max(14, Math.min(36,  W * 0.028));
    const sub2Size = Math.max(12, Math.min(26,  W * 0.020));

    octx.textAlign = "center";
    octx.textBaseline = "middle";

    // "Terminal glow" do texto (desenha 2x: sombra + texto)
    octx.font = `900 ${mainSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    octx.fillStyle = "rgba(67,255,153,0.35)";
    octx.fillText(MSG, W/2, H * 0.44);

    octx.fillStyle = "#ffffff";
    octx.fillText(MSG, W/2, H * 0.44);

    octx.globalAlpha = 0.95;
    octx.font = `700 ${subSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    octx.fillStyle = "#ffffff";
    octx.fillText(SUB, W/2, H * 0.55);

    octx.globalAlpha = 0.85;
    octx.font = `600 ${sub2Size}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    octx.fillStyle = "#cfe6ff";
    octx.fillText(SUB2, W/2, H * 0.61);
    octx.globalAlpha = 1;

    const img = octx.getImageData(0, 0, W, H).data;

    const targets = [];
    const step = Math.max(3, Math.floor(cfg.dotGap));

    for (let y = 0; y < H; y += step) {
      for (let x = 0; x < W; x += step) {
        const i = (y * W + x) * 4;
        const a = img[i + 3];
        if (a > 25) {
          if (cfg.density < 1 && Math.random() > cfg.density) continue;
          targets.push({ x, y, a });
        }
      }
    }

    const old = particles;
    particles = new Array(targets.length);

    for (let i = 0; i < targets.length; i++) {
      const t = targets[i];
      const prev = old[i % Math.max(1, old.length)];

      const startX = prev ? prev.x : (W/2 + (Math.random()-0.5)*60);
      const startY = prev ? prev.y : (H/2 + (Math.random()-0.5)*60);

      // "classe" visual baseada no alfa do texto (mais forte no MSG)
      const kind = t.a > 200 ? 0 : (t.a > 120 ? 1 : 2);

      particles[i] = {
        x: startX, y: startY,
        vx: prev ? prev.vx : 0,
        vy: prev ? prev.vy : 0,
        tx: t.x, ty: t.y,
        r: cfg.dotRadius * (0.85 + Math.random()*0.55),
        kind,
        seed: Math.random()
      };
    }
  }

  function keepInBounds(p) {
    if (p.x < p.r) { p.x = p.r; p.vx *= -0.45; }
    else if (p.x > W - p.r) { p.x = W - p.r; p.vx *= -0.45; }

    if (p.y < p.r) { p.y = p.r; p.vy *= -0.45; }
    else if (p.y > H - p.r) { p.y = H - p.r; p.vy *= -0.45; }
  }

  function update() {
    const R = cfg.repelRadius;
    const R2 = R * R;

    for (const p of particles) {
      // retorno ao texto
      const dxT = p.tx - p.x;
      const dyT = p.ty - p.y;
      p.vx += dxT * cfg.returnStrength;
      p.vy += dyT * cfg.returnStrength;

      // repuls√£o at√© equil√≠brio (anel)
      if (pointer.active) {
        const dx = p.x - pointer.x;
        const dy = p.y - pointer.y;
        const d2 = dx*dx + dy*dy;

        if (d2 > 0.0001 && d2 < R2) {
          const d = Math.sqrt(d2);
          const nx = dx / d;
          const ny = dy / d;

          // s√≥ empurra se estiver dentro do "eqDist"
          const delta = cfg.eqDist - d;
          if (delta > cfg.deadBand) {
            // for√ßa ~ (delta/eqDist) * 1/(d+eps) com falloff at√© R
            const ringFactor = delta / cfg.eqDist;
            const inv = 1 / (d + cfg.eps);
            const radiusFalloff = 1 - d / R;
            const force = cfg.repelStrength * ringFactor * inv * radiusFalloff;

            p.vx += nx * force;
            p.vy += ny * force;
          }
        }
      }

      // jitter opcional
      if (cfg.jitter > 0) {
        p.vx += (Math.random()-0.5) * cfg.jitter;
        p.vy += (Math.random()-0.5) * cfg.jitter;
      }

      // amortecimento
      p.vx *= cfg.damping;
      p.vy *= cfg.damping;

      // limita velocidade
      const sp2 = p.vx*p.vx + p.vy*p.vy;
      const ms = cfg.maxSpeed;
      if (sp2 > ms*ms) {
        const s = Math.sqrt(sp2);
        p.vx = (p.vx / s) * ms;
        p.vy = (p.vy / s) * ms;
      }

      // integra
      p.x += p.vx;
      p.y += p.vy;

      keepInBounds(p);
    }
  }

  function drawCursor(x, y) {
    // cursor estilizado (crosshair + brackets)
    ctx.globalAlpha = 0.65;
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = "#43ff99";

    const s = 10;
    ctx.beginPath();
    ctx.moveTo(x - s, y);
    ctx.lineTo(x + s, y);
    ctx.moveTo(x, y - s);
    ctx.lineTo(x, y + s);
    ctx.stroke();

    const b = 16;
    ctx.beginPath();
    ctx.moveTo(x - b, y - b/2);
    ctx.lineTo(x - b, y - b);
    ctx.lineTo(x - b/2, y - b);
    ctx.moveTo(x + b, y - b/2);
    ctx.lineTo(x + b, y - b);
    ctx.lineTo(x + b/2, y - b);

    ctx.moveTo(x - b, y + b/2);
    ctx.lineTo(x - b, y + b);
    ctx.lineTo(x - b/2, y + b);
    ctx.moveTo(x + b, y + b/2);
    ctx.lineTo(x + b, y + b);
    ctx.lineTo(x + b/2, y + b);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function render() {
    drawBackground();

    // part√≠culas com "estilo dev" (verdinhas/brancas/azuladas)
    for (const p of particles) {
      let glow = 0;
      if (pointer.active) {
        const dx = p.x - pointer.x;
        const dy = p.y - pointer.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        glow = clamp(1 - d / cfg.repelRadius, 0, 1);
      }

      // cor por "kind" (MSG mais verde, resto mais claro/azulado)
      // sem usar HSL pesado ‚Äî usa RGB fixo por tipo
      let r = 240, g = 245, b = 255;
      if (p.kind === 0) { r = 120; g = 255; b = 190; }      // verde terminal
      else if (p.kind === 1) { r = 235; g = 250; b = 255; } // branco frio
      else { r = 200; g = 220; b = 255; }                   // azulado

      // brilho extra perto do ponteiro
      const a = 0.88 + glow * 0.12;
      ctx.globalAlpha = a;

      // glow halo
      if (glow > 0.02) {
        ctx.globalAlpha = 0.10 * glow;
        ctx.fillStyle = "rgba(67,255,153,1)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * (3.2 + glow * 3.0), 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = a;
      }

      ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // "c√≥digo caindo" bem leve no fundo (apenas visual, baratinho)
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "#43ff99";
    const cols = Math.floor(W / 26);
    for (let i = 0; i < cols; i++) {
      const x = i * 26 + 8;
      const y = (i * 97 + performance.now() * 0.06) % (H + 120) - 120;
      ctx.fillRect(x, y, 2, 18);
      ctx.fillRect(x, y + 26, 2, 10);
    }
    ctx.globalAlpha = 1;

    if (pointer.active) drawCursor(pointer.x, pointer.y);
  }

  function loop() {
    update();
    render();
    requestAnimationFrame(loop);
  }

  // Intera√ß√£o
  window.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;
    pointer.active = true;
  }, { passive: true });

  window.addEventListener("mouseleave", () => { pointer.active = false; }, { passive: true });

  function setPointerFromTouch(t) {
    const rect = canvas.getBoundingClientRect();
    pointer.x = t.clientX - rect.left;
    pointer.y = t.clientY - rect.top;
    pointer.active = true;
  }

  window.addEventListener("touchstart", (e) => {
    if (e.touches && e.touches[0]) setPointerFromTouch(e.touches[0]);
  }, { passive: true });

  window.addEventListener("touchmove", (e) => {
    if (e.touches && e.touches[0]) setPointerFromTouch(e.touches[0]);
  }, { passive: true });

  window.addEventListener("touchend", () => { pointer.active = false; }, { passive: true });

  canvas.addEventListener("pointerdown", (e) => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;
    pointer.active = true;
  }, { passive: true });

  canvas.addEventListener("pointermove", (e) => {
    if (!pointer.active && e.pointerType === "mouse") return;
    const rect = canvas.getBoundingClientRect();
    pointer.x = e.clientX - rect.left;
    pointer.y = e.clientY - rect.top;
  }, { passive: true });

  canvas.addEventListener("pointerup", () => { pointer.active = false; }, { passive: true });

  window.addEventListener("resize", resize, { passive: true });

  // Start
  resize();
  loop();
})();
</script>
</body>
</html>
