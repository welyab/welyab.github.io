<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>üéÑ Dev Noel: Hotfix Run</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#04060c; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    .ui {
      position: fixed; inset: 0; pointer-events: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: rgba(255,255,255,.86);
    }
    .topbar {
      position: absolute; left: 12px; right: 12px; top: 12px;
      display: flex; gap: 10px; align-items: center; justify-content: space-between;
    }
    .pill {
      pointer-events: none;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      display: inline-flex; gap: 10px; align-items: center;
      font-size: 12px;
      white-space: nowrap;
    }
    .center {
      position: absolute; left: 0; right: 0; top: 0; bottom: 0;
      display: grid; place-items: center;
      padding: 18px;
    }
    .card {
      pointer-events: auto;
      width: min(560px, calc(100vw - 24px));
      background: rgba(0,0,0,.40);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      padding: 16px 16px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    .title {
      font-size: 16px; font-weight: 800;
      color: rgba(255,255,255,.95);
      margin-bottom: 8px;
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px;
    }
    .subtitle { font-size: 12px; color: rgba(255,255,255,.76); line-height: 1.35; }
    .btnrow { display:flex; gap: 10px; margin-top: 12px; }
    button {
      pointer-events: auto;
      appearance: none;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      border-radius: 14px;
      padding: 10px 12px;
      font: 700 13px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      cursor: pointer;
      flex: 1;
    }
    button:active { transform: scale(0.98); }
    .small { font-size: 11px; opacity: .85; }
    .footerhint {
      margin-top: 10px; font-size: 11px; color: rgba(255,255,255,.68);
    }
    .kbd {
      display:inline-block; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06);
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="topbar">
    <div class="pill" id="leftPill">üéÑ Dev Noel: <span style="opacity:.9">Hotfix Run</span></div>
    <div class="pill" id="rightPill">score: 0 ¬∑ streak: 0 ¬∑ ‚ô•‚ô•‚ô•</div>
  </div>

  <div class="center" id="overlay">
    <div class="card">
      <div class="title">
        <span>üéÅ Dev Noel: Hotfix Run</span>
        <span class="small" id="ver">v1.0</span>
      </div>
      <div class="subtitle">
        Voc√™ √© o <b>cursor</b> de um dev natalino.<br/>
        Colete <b>commits ‚úÖ</b> (presentes) e desvie de <b>bugs üêõ</b> e <b>erros ‚ùå</b>.<br/><br/>
        <b>Como jogar (celular):</b> toque e arraste para mover o cursor. Solte para parar.<br/>
        <b>Desktop:</b> mouse / toque tamb√©m funciona.
      </div>
      <div class="btnrow">
        <button id="playBtn">‚ñ∂ Jogar</button>
        <button id="howBtn">‚Ñπ Dicas</button>
      </div>
      <div class="footerhint" id="hintText">
        Dica: fa√ßa ‚Äúcombo‚Äù pegando commits seguidos sem levar dano.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const rightPill = document.getElementById("rightPill");
  const overlay = document.getElementById("overlay");
  const playBtn = document.getElementById("playBtn");
  const howBtn  = document.getElementById("howBtn");
  const hintText= document.getElementById("hintText");

  // ======= VISUAL: mensagem em part√≠culas (fundo) =======
  const TEXT_MAIN = "Feliz Natal, Dev!";
  const TEXT_SUB  = "git commit -m \"Merry Christmas\"";
  const TEXT_SUB2 = "CI ‚úÖ  |  tests ‚úÖ  |  build ‚úÖ  |  deploy üéÅ";

  const particleCfg = {
    dotRadius: 2.0,
    dotGap: 5,
    density: 1.0,

    eqDist: 92,       // anel de equil√≠brio do ponteiro
    deadBand: 3,
    repelRadius: 210,
    repelStrength: 980,
    eps: 10,

    returnStrength: 0.07,
    damping: 0.86,
    maxSpeed: 14
  };

  const DPR_LIMIT = 2;
  let W=0,H=0,dpr=1;

  const pointer = { x: 0, y: 0, active: false }; // tamb√©m vira "cursor" do jogo
  let bgParticles = [];

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, DPR_LIMIT);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = Math.floor(W*dpr);
    canvas.height = Math.floor(H*dpr);
    canvas.style.width  = W+"px";
    canvas.style.height = H+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);

    buildTextParticles();
    // Centraliza jogador quando redimensiona
    player.x = W*0.5; player.y = H*0.72;
  }

  function buildTextParticles(){
    const off = document.createElement("canvas");
    const octx = off.getContext("2d");
    off.width=W; off.height=H;
    octx.clearRect(0,0,W,H);

    const mainSize = Math.max(40, Math.min(150, W*0.09));
    const subSize  = Math.max(14, Math.min(36,  W*0.028));
    const sub2Size = Math.max(12, Math.min(26,  W*0.020));

    octx.textAlign="center";
    octx.textBaseline="middle";

    // glow terminal
    octx.font = `900 ${mainSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    octx.fillStyle = "rgba(67,255,153,0.35)";
    octx.fillText(TEXT_MAIN, W/2, H*0.20);
    octx.fillStyle = "#ffffff";
    octx.fillText(TEXT_MAIN, W/2, H*0.20);

    octx.globalAlpha = 0.92;
    octx.font = `700 ${subSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    octx.fillStyle = "#ffffff";
    octx.fillText(TEXT_SUB, W/2, H*0.30);

    octx.globalAlpha = 0.82;
    octx.font = `600 ${sub2Size}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    octx.fillStyle = "#cfe6ff";
    octx.fillText(TEXT_SUB2, W/2, H*0.35);
    octx.globalAlpha = 1;

    const img = octx.getImageData(0,0,W,H).data;
    const step = Math.max(3, Math.floor(particleCfg.dotGap));
    const targets = [];

    for(let y=0;y<H;y+=step){
      for(let x=0;x<W;x+=step){
        const i=(y*W+x)*4;
        const a=img[i+3];
        if(a>25){
          if(particleCfg.density<1 && Math.random()>particleCfg.density) continue;
          const kind = a>200?0:(a>120?1:2);
          targets.push({x,y,kind});
        }
      }
    }

    const old = bgParticles;
    bgParticles = new Array(targets.length);

    for(let i=0;i<targets.length;i++){
      const t=targets[i];
      const prev = old[i % Math.max(1, old.length)];
      bgParticles[i] = {
        x: prev?prev.x:(W/2+(Math.random()-0.5)*60),
        y: prev?prev.y:(H/2+(Math.random()-0.5)*60),
        vx: prev?prev.vx:0,
        vy: prev?prev.vy:0,
        tx: t.x, ty: t.y,
        r: particleCfg.dotRadius*(0.85+Math.random()*0.55),
        kind: t.kind
      };
    }
  }

  function keepInBounds(p){
    if(p.x<p.r){p.x=p.r; p.vx*=-0.45;}
    else if(p.x>W-p.r){p.x=W-p.r; p.vx*=-0.45;}
    if(p.y<p.r){p.y=p.r; p.vy*=-0.45;}
    else if(p.y>H-p.r){p.y=H-p.r; p.vy*=-0.45;}
  }

  function updateTextParticles(){
    const R = particleCfg.repelRadius;
    const R2 = R*R;

    for(const p of bgParticles){
      // retorno ao alvo
      p.vx += (p.tx - p.x)*particleCfg.returnStrength;
      p.vy += (p.ty - p.y)*particleCfg.returnStrength;

      // repuls√£o com anel
      if(pointer.active){
        const dx = p.x - pointer.x;
        const dy = p.y - pointer.y;
        const d2 = dx*dx + dy*dy;
        if(d2>0.0001 && d2<R2){
          const d = Math.sqrt(d2);
          const nx = dx/d, ny = dy/d;
          const delta = particleCfg.eqDist - d;
          if(delta > particleCfg.deadBand){
            const ringFactor = delta / particleCfg.eqDist;
            const inv = 1/(d + particleCfg.eps);
            const fall = 1 - d/R;
            const force = particleCfg.repelStrength * ringFactor * inv * fall;
            p.vx += nx*force;
            p.vy += ny*force;
          }
        }
      }

      p.vx *= particleCfg.damping;
      p.vy *= particleCfg.damping;

      // limita
      const sp2 = p.vx*p.vx + p.vy*p.vy;
      const ms = particleCfg.maxSpeed;
      if(sp2>ms*ms){
        const s=Math.sqrt(sp2);
        p.vx = (p.vx/s)*ms;
        p.vy = (p.vy/s)*ms;
      }

      p.x += p.vx;
      p.y += p.vy;
      keepInBounds(p);
    }
  }

  function drawBackground(){
    // gradiente "monitor"
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#061027");
    g.addColorStop(1, "#03040a");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);

    // glow verde suave
    ctx.globalAlpha=0.10;
    ctx.fillStyle="#43ff99";
    ctx.beginPath();
    ctx.arc(W*0.16, H*0.18, Math.min(W,H)*0.20, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha=1;

    // grade discreta
    ctx.globalAlpha=0.06;
    ctx.strokeStyle="#ffffff";
    ctx.lineWidth=1;
    const step=34;
    for(let x=0;x<=W;x+=step){
      ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,H); ctx.stroke();
    }
    for(let y=0;y<=H;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke();
    }
    ctx.globalAlpha=1;

    // "code rain" barato
    ctx.globalAlpha=0.08;
    ctx.fillStyle="#43ff99";
    const cols = Math.floor(W/26);
    const t = performance.now()*0.06;
    for(let i=0;i<cols;i++){
      const x=i*26+8;
      const y=(i*97+t)%(H+140)-140;
      ctx.fillRect(x,y,2,18);
      ctx.fillRect(x,y+26,2,10);
    }
    ctx.globalAlpha=1;
  }

  function drawTextParticles(){
    for(const p of bgParticles){
      // cor por tipo (verde/branco/azul)
      let r=240,g=245,b=255;
      if(p.kind===0){ r=120; g=255; b=190; }
      else if(p.kind===1){ r=235; g=250; b=255; }
      else { r=200; g=220; b=255; }

      ctx.globalAlpha=0.86;
      ctx.fillStyle=`rgb(${r|0},${g|0},${b|0})`;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  function drawCursor(x,y){
    ctx.globalAlpha=0.75;
    ctx.lineWidth=1.6;
    ctx.strokeStyle="#43ff99";
    const s=10, b=16;

    ctx.beginPath();
    ctx.moveTo(x-s,y); ctx.lineTo(x+s,y);
    ctx.moveTo(x,y-s); ctx.lineTo(x,y+s);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x-b,y-b/2); ctx.lineTo(x-b,y-b); ctx.lineTo(x-b/2,y-b);
    ctx.moveTo(x+b,y-b/2); ctx.lineTo(x+b,y-b); ctx.lineTo(x+b/2,y-b);
    ctx.moveTo(x-b,y+b/2); ctx.lineTo(x-b,y+b); ctx.lineTo(x-b/2,y+b);
    ctx.moveTo(x+b,y+b/2); ctx.lineTo(x+b,y+b); ctx.lineTo(x+b/2,y+b);
    ctx.stroke();

    ctx.globalAlpha=1;
  }

  // ======= JOGO =======
  const game = {
    state: "menu", // menu | playing | over
    score: 0,
    streak: 0,
    lives: 3,
    time: 0,
    spawnT: 0,
    speed: 1,
    best: 0
  };

  const player = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    r: 16,
    targetX: 0,
    targetY: 0,
    dragging: false
  };

  const items = []; // {x,y,vx,vy,r,type,rot}
  // type: "commit"(bom) | "bug"(ruim) | "error"(ruim)

  function resetGame(){
    game.state="playing";
    game.score=0;
    game.streak=0;
    game.lives=3;
    game.time=0;
    game.spawnT=0;
    game.speed=1;
    items.length=0;

    player.x = W*0.5;
    player.y = H*0.72;
    player.vx = player.vy = 0;
    player.targetX = player.x;
    player.targetY = player.y;
    player.dragging = false;

    pointer.x = player.x;
    pointer.y = player.y;
    pointer.active = true; // o cursor do jogo tamb√©m move o fundo
    overlay.style.display="none";
  }

  function endGame(){
    game.state="over";
    game.best = Math.max(game.best, game.score);
    overlay.style.display="grid";
    hintText.innerHTML =
      `Fim de jogo! score: <b>${game.score}</b> ¬∑ best: <b>${game.best}</b><br/>` +
      `Tente de novo e fa√ßa um combo de commits ‚úÖ sem tomar bug üêõ.`;
    playBtn.textContent = "‚Üª Jogar de novo";
  }

  function spawn(){
    // aumento gradual
    const difficulty = 1 + game.time/25000; // cresce devagar
    game.speed = clamp(difficulty, 1, 2.3);

    // decide tipo
    const p = Math.random();
    let type = "commit";
    if(p < 0.18) type = "bug";
    else if(p < 0.30) type = "error"; // total ~30% ruim, 70% bom

    // spawn na parte de cima
    const margin = 22;
    const x = margin + Math.random()*(W - margin*2);
    const y = -20;
    const r = type==="commit" ? 14 : 14;
    const vx = (Math.random()-0.5) * 0.6 * game.speed;
    const vy = (1.2 + Math.random()*1.3) * game.speed;

    items.push({ x,y,vx,vy,r,type,rot:Math.random()*Math.PI*2 });
  }

  function updateGame(dt){
    if(game.state!=="playing") return;

    game.time += dt;
    game.spawnT += dt;

    // taxa de spawn: come√ßa mais lenta e acelera
    const baseEvery = 520; // ms
    const every = clamp(baseEvery - game.time/100, 260, 520);
    while(game.spawnT > every){
      game.spawnT -= every;
      spawn();
    }

    // movimento do jogador: segue o dedo/mouse (drag)
    // suaviza, mas ainda responsivo
    const follow = 0.020 * dt; // proporcional ao tempo
    player.x += (player.targetX - player.x) * clamp(follow, 0.08, 0.35);
    player.y += (player.targetY - player.y) * clamp(follow, 0.08, 0.35);

    // mant√©m dentro
    player.x = clamp(player.x, player.r, W-player.r);
    player.y = clamp(player.y, player.r, H-player.r);

    // sincroniza ponteiro do fundo com o cursor do jogo
    pointer.x = player.x;
    pointer.y = player.y;
    pointer.active = true;

    // itens caindo
    for(let i=items.length-1;i>=0;i--){
      const it = items[i];
      it.x += it.vx * (dt/16.67);
      it.y += it.vy * (dt/16.67);
      it.rot += 0.0025*dt*(it.type==="commit"?1:1.4);

      // remove se saiu
      if(it.y > H + 40){
        items.splice(i,1);
        // se perdeu commit (bom), quebra streak
        if(it.type==="commit") game.streak = 0;
        continue;
      }

      // colis√£o com jogador
      const dx = it.x - player.x;
      const dy = it.y - player.y;
      const rr = it.r + player.r;
      if(dx*dx + dy*dy < rr*rr){
        if(it.type==="commit"){
          // pontua√ß√£o com combo
          game.streak++;
          const combo = clamp(game.streak, 1, 12);
          const gain = 10 + combo*2;
          game.score += gain;
        } else {
          game.streak = 0;
          game.lives--;
          // ‚Äúempurr√£o‚Äù visual
          player.targetX = clamp(player.targetX + (Math.random()-0.5)*120, player.r, W-player.r);
          player.targetY = clamp(player.targetY + (Math.random()-0.5)*120, player.r, H-player.r);
          if(game.lives <= 0){
            items.splice(i,1);
            endGame();
            return;
          }
        }
        items.splice(i,1);
      }
    }

    // update HUD
    const hearts = "‚ô•".repeat(game.lives) + "‚ô°".repeat(3-game.lives);
    rightPill.textContent = `score: ${game.score} ¬∑ streak: ${game.streak} ¬∑ ${hearts}`;
  }

  function drawGame(){
    if(game.state==="menu"){
      rightPill.textContent = `score: 0 ¬∑ streak: 0 ¬∑ ‚ô•‚ô•‚ô•`;
    }
    if(game.state==="over"){
      const hearts = "‚ô•".repeat(Math.max(0,game.lives)) + "‚ô°".repeat(3-Math.max(0,game.lives));
      rightPill.textContent = `score: ${game.score} ¬∑ streak: ${game.streak} ¬∑ ${hearts}`;
    }

    // desenha player
    // ‚Äúcursor‚Äù (crosshair + caret)
    drawCursor(player.x, player.y);

    // desenha itens
    for(const it of items){
      if(it.type==="commit"){
        // ‚úÖ caixa "commit"
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(67,255,153,0.14)";
        ctx.strokeStyle = "rgba(67,255,153,0.55)";
        ctx.lineWidth = 1.4;
        const w=54, h=28, r=10;
        const x=it.x-w/2, y=it.y-h/2;
        roundRect(ctx,x,y,w,h,r);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("commit ‚úÖ", it.x, it.y);
      } else if(it.type==="bug"){
        // üêõ "bug"
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(255,120,120,0.12)";
        ctx.strokeStyle = "rgba(255,120,120,0.55)";
        ctx.lineWidth = 1.4;
        const w=46, h=28, r=10;
        const x=it.x-w/2, y=it.y-h/2;
        roundRect(ctx,x,y,w,h,r);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("bug üêõ", it.x, it.y);
      } else {
        // ‚ùå "error"
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(255,200,90,0.12)";
        ctx.strokeStyle = "rgba(255,200,90,0.55)";
        ctx.lineWidth = 1.4;
        const w=54, h=28, r=10;
        const x=it.x-w/2, y=it.y-h/2;
        roundRect(ctx,x,y,w,h,r);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("error ‚ùå", it.x, it.y);
      }
      ctx.globalAlpha = 1;
    }

    // ‚Äúlinha de status‚Äù tipo terminal
    if(game.state==="playing"){
      ctx.globalAlpha=0.85;
      ctx.fillStyle="rgba(0,0,0,0.30)";
      ctx.strokeStyle="rgba(255,255,255,0.10)";
      ctx.lineWidth=1;
      roundRect(ctx, 12, H-56, W-24, 44, 14);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="700 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace";
      ctx.textAlign="left"; ctx.textBaseline="middle";

      const msg = game.streak>=6
        ? `> npm test && npm run build  // streak ${game.streak} üî•`
        : (game.streak>=3
           ? `> git push origin main  // streak ${game.streak} ‚ú®`
           : `> console.log("Feliz Natal!")  // colete commits ‚úÖ`);

      ctx.fillText(msg, 22, H-34);
      ctx.globalAlpha=1;
    }
  }

  function roundRect(c,x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  // ======= LOOP =======
  let last = performance.now();
  function frame(now){
    const dt = now - last;
    last = now;

    updateTextParticles();
    updateGame(dt);

    drawBackground();
    drawTextParticles();
    drawGame();

    requestAnimationFrame(frame);
  }

  // ======= CONTROLES (mobile-first) =======
  function setTargetFromClient(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    player.targetX = x;
    player.targetY = y;
  }

  // toque/arraste
  canvas.addEventListener("pointerdown", (e)=>{
    if(game.state==="menu" || game.state==="over") return; // evita mexer no menu
    player.dragging = true;
    setTargetFromClient(e.clientX, e.clientY);
    pointer.active = true;
  }, {passive:true});

  canvas.addEventListener("pointermove", (e)=>{
    if(!player.dragging) return;
    setTargetFromClient(e.clientX, e.clientY);
  }, {passive:true});

  canvas.addEventListener("pointerup", ()=>{
    player.dragging = false;
  }, {passive:true});

  canvas.addEventListener("pointercancel", ()=>{
    player.dragging = false;
  }, {passive:true});

  // no desktop, tamb√©m segue o mouse (mais confort√°vel)
  window.addEventListener("mousemove", (e)=>{
    if(game.state!=="playing") return;
    if(player.dragging) return; // se estiver arrastando, ignore
    setTargetFromClient(e.clientX, e.clientY);
  }, {passive:true});

  // ======= BOT√ïES =======
  playBtn.addEventListener("click", ()=>{
    resetGame();
  });

  howBtn.addEventListener("click", ()=>{
    hintText.innerHTML =
      `‚úÖ Pegue <b>commits</b> para somar pontos.<br/>` +
      `üêõ/‚ùå encostar tira uma vida.<br/>` +
      `Fa√ßa <b>streak</b> para ganhar mais pontos.<br/>` +
      `<span class="small">Dica mobile: toque e arraste com o polegar; solte para reposicionar com calma.</span>`;
  });

  // ======= START =======
  window.addEventListener("resize", resize, {passive:true});
  resize();

  // Estado inicial: menu com fundo animado seguindo "ponteiro fake"
  // para dar vida mesmo antes de jogar
  let fakeAngle = 0;
  function menuPointerWiggle(){
    if(game.state==="menu"){
      fakeAngle += 0.012;
      pointer.active = true;
      pointer.x = W*0.5 + Math.cos(fakeAngle)*120;
      pointer.y = H*0.55 + Math.sin(fakeAngle*1.2)*70;
      // jogador fica ‚Äúestacionado‚Äù
      player.x = W*0.5; player.y = H*0.72;
      player.targetX = player.x; player.targetY = player.y;
    }
    requestAnimationFrame(menuPointerWiggle);
  }
  menuPointerWiggle();

  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
